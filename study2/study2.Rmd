---
title: "Illusion Game Validation (part 1)"
author: "Dominique Makowski et al."
output:
  html_document:
    toc: true
    toc_depth: 2
    theme: paper
    code_folding: hide
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
bibliography: "../submission/references.bib"
---

```{r, echo = FALSE, warning=FALSE, message=FALSE}
options(
  digits = 3,
  mc.cores = 4,
  brms.algorithm = "sampling",
  brms.backend = "cmdstanr"
)

cache <- TRUE
runModels <- FALSE
bestModels <- TRUE
fig.width <- see::golden_ratio(7)
fig.height <- 7

knitr::opts_chunk$set(
  collapse = TRUE,
  dpi = 450,
  fig.path = "./figures/",
  fig.width = fig.width,
  fig.height = fig.height
)
```

# Introduction


The aim of part 1 is two-fold. In the first part, we will carefully model the error rate and the reaction time of each illusion type in order to validate our novel paradigm and show that the effect of illusions can be manipulated continuously. In the second part, we will derive the participant-level scores from the models (i.e., the effect of illusion strength for each individual) and analyze their latent factors structure.


# Methods


```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# PREPROCESSING ================================================================
source("preprocessing.R")

# This is a local folder containing raw data from unzipped pavlovia
# It has been added to .gitignore to NOT be published on github
# (it contains the subject ID of the participants)
participants <- list.files("data/")

df <- data.frame()
for (ppt in participants) {
  df <- rbind(df, preprocess_raw(file = paste0("data/", ppt)))
}

df$Pyllusion <- "1.2"

# Fix due to technical issue in the paradigm on the first day
df[df$Illusion_Type == "Rod-Frame" & df$Date == "05/08/2022", "Illusion_Strength"] <- -1 * (df[df$Illusion_Type == "Rod-Frame" & df$Date == "05/08/2022", "Illusion_Strength"])
df[df$Illusion_Type == "Rod-Frame" & df$Date == "05/08/2022", "Illusion_Effect"] <- ifelse(sign(df[df$Illusion_Type == "Rod-Frame" & df$Date == "05/08/2022", "Illusion_Strength"]) == -1, "Congruent", "Incongruent")

# Anonymize
replacement <- paste0("S", str_pad(1:length(unique(df$Participant)), 2, pad = "0"))
names(replacement) <- unique(df$Participant)
df$Participant <- replacement[df$Participant]


# Save anonymized data
write.csv(df[1:150000, ], "../data/study2_part1.csv", row.names = FALSE)
write.csv(df[150001:nrow(df), ], "../data/study2_part2.csv", row.names = FALSE)
```


```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(ggdist)
library(ggside)
library(easystats)
library(patchwork)
library(brms)
source("functions.R")

df <- read.csv("../data/study2_part1.csv") |>
  rbind(read.csv("../data/study2_part2.csv")) |> 
  mutate(
    Date = lubridate::dmy(Date),
    Participant = fct_reorder(Participant, Date),
    Screen_Refresh = as.character(Screen_Refresh),
    Illusion_Side = as.factor(Illusion_Side),
    # Illusion_Effect = fct_relevel(as.factor(Illusion_Effect), "Incongruent", "Null", "Congruent"),
    Illusion_Effect = fct_relevel(as.factor(Illusion_Effect), "Incongruent", "Congruent"),
    Block = as.factor(Block),
    Education = fct_relevel(Education, "High School", "Bachelor", "Master", "Doctorate", "Other", "Prefer not to Say")
  )

# Fix precision
for(ill in unique(df$Illusion_Type)) {
  data <- df[df$Illusion_Type == ill, ] 
  i <- 10
  while (length(sort(unique(signif(data$Illusion_Difference, i)))) != 8) {
    i <- i - 1
  }
  df[df$Illusion_Type == ill, "Illusion_Difference"] <- signif(df[df$Illusion_Type == ill, "Illusion_Difference"], i)
  if (i != 10) {
    message(ill, ": Illusion_Difference values != 8. Rounded to ", i, ".")
  }
}

# Transformation
df <- df |> 
  mutate(    
    Illusion_Difference_log = log(1 + Illusion_Difference),
    Illusion_Difference_sqrt = sqrt(Illusion_Difference),
    Illusion_Difference_cbrt = Illusion_Difference**(1 / 3),
    Illusion_Strength_log = sign(Illusion_Strength) * log(1 + abs(Illusion_Strength)),
    Illusion_Strength_sqrt = sign(Illusion_Strength) * sqrt(abs(Illusion_Strength)),
    Illusion_Strength_cbrt = sign(Illusion_Strength) * (abs(Illusion_Strength)**(1 / 3))
    )
```


## Exclusions {.tabset}

```{r message=FALSE, warning=FALSE}
# plot(estimate_density(dfraw[dfraw$Participant == "60684f29dbfe1bb2059e5e27_rkqoy", "RT"]))

# Dear participant, thank you for participating in our studfy. Unfortunately, we didn't receive your data :( did something happen? Some technical issue? We would like to kindly ask you to return your participation so that we can open up more slots. Thank you in advance, and apologies for the inconvenience! 

# Dear participant, thank you for participating in our study. Unfortunately, our system detected multiple issues in your data (such as implausibly short responses, and random-like pattern of answers), which makes it unusable. We understand that you might have been in a hurry or had some other issues; we hope to open-up more slots in the future would you be interested to participate again.

# Dear participant, thank you for participating in our study. Unfortunately, our system detected multiple issues in your data (such as implausibly short responses, and random-like pattern of answers - in particular in the 2nd part of the study), which makes it unusable. We understand that you might have been in a hurry or had some other issues, and so we kindly ask you to return your participation; we hope to open-up more slots in the future would you be interested to participate again.

# Just received the results: in your case, the three most prominent issues were your response pattern that was equivalent to random (in the sequence of keystrokes) that led to a chance-level performance (that was also significantly different from the rest of the population). Moreover, your reaction time distribution was also very different from the norm, with a vast majority of implausibly short responses (i.e., that are faster than the time it takes the brain to process a visual input). This issue was even more prominent in the second block (after the break), which typically happens when participants are in a rush to finish. Finally, your overall completion time was also significantly below the average. Again, we apologize, we understand that your time is valuable, but unfortunately we run too on limited funds and can hardly spare more on unusable data. Sorry for the inconvenience, we will try to open-up more slots soon.


outliers <- c(
  # Error rate of 48.8% Very short RT
  # Prolific Status: REJECTED (06/08)
  "S46",
  # 2nd block of responses very fast
  # Prolific Status: REJECTED (15/08)
  "S221",
  # Error rate of 44% and very short RTs
  # Prolific Status: RETURN REQUESTED (22/08)
  "S154",
  # 2nd block bad, first block 1/3 bad
  # Prolific Status: RETURN REQUESTED (26/08)
  "S68",
  # Prolific Status: RETURN REQUESTED (26/08)
  "S238",
  # Prolific status: accepted (not enough proof)
  "S201"
)

partial_outliers <- c(
  # 2nd block a bit bad
  "S22", 
  # Entire 2nd block bad
  "S235",
  # Entire 2nd block bad
  "S107",
  # Half of 2nd block bad
  "S204",
  # 2nd block not good
  "S140")
```

We removed `r length(outliers)` participants upon inspection of the average error rage (when close to 50%, suggesting random answers) and/or when the reaction time distribution was implausibly fast. 

For each block, we computed the error rate and, if more than 50%, we discarded the whole block (as it likely indicates that instructions got mixed up, for instance participants were selecting the smaller instead of the bigger circle).



### Descriptive Table

```{r message=FALSE, warning=FALSE}
dfsub <- df |>
  group_by(Participant) |>
  summarize(
    # n = n(),
    Error = sum(Error) / n(),
    RT_Mean = mean(RT),
    RT_SD = sd(RT),
    IPIP6_SD = mean(IPIP6_SD),
    PID5_SD = mean(PID5_SD),
  ) |>
  ungroup() |>
  arrange(desc(Error))
```



```{r message=FALSE, warning=FALSE}
data.frame(Participant = c("Total"), t(sapply(dfsub[2:ncol(dfsub)], mean, na.rm=TRUE))) |> 
  rbind(dfsub) |> 
  knitr::kable() |>
  kableExtra::row_spec(1, italic = TRUE) |> 
  kableExtra::row_spec(which(dfsub$Participant %in% outliers) + 1, background = "#EF9A9A") |> 
  kableExtra::row_spec(which(dfsub$Participant %in% partial_outliers) + 1, background = "#FFECB3") |> 
  kableExtra::kable_styling(full_width = TRUE) |> 
  kableExtra::scroll_box(width = "100%", height = "500px")
```



### Reaction Time Distribution


```{r outliers_RT, message=FALSE, warning=FALSE, fig.width=20, fig.height=20, cache=cache}
# RT distribution
p <- df |> 
  filter(RT < 10000) |> 
  estimate_density(select = "RT", at = c("Participant", "Block")) |>
  group_by(Participant) |>
  normalize(select = "y") |>
  ungroup() |>
  mutate(Participant = fct_relevel(Participant, as.character(dfsub$Participant))) |> 
  mutate(color = ifelse(Participant %in% outliers, "red", ifelse(Participant %in% partial_outliers, "orange", "blue"))) |>
  ggplot(aes(x = x, y = y)) +
  geom_area(data = normalize(estimate_density(filter(df, RT < 10000), select = "RT"), select = "y"), alpha = 0.2) +
  geom_line(aes(color = color, group = interaction(Participant, Block), linetype = Block)) +
  geom_vline(xintercept = 125, linetype = "dashed", color = "red") +
  scale_color_manual(values = c("red" = "#F44336", "orange" = "#FF9800", "blue" = "blue"), guide = "none") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  coord_cartesian(xlim = c(0, 3000)) +
  theme_modern() +
  theme(axis.text.y = element_blank()) +
  facet_wrap(~Participant) +
  labs(y = "", x = "Reaction Time (ms)")
# p
# ggsave("figures/outliers.png", p, width=25, height=25)

# Filter out
df <- filter(df, !Participant %in% outliers)
```


### Error Rate per Illusion Block

```{r outliers_errorblock, message=FALSE, warning=FALSE}
temp <- df |>
  group_by(Participant, Illusion_Type, Block) |>
  summarize(ErrorRate_per_block = sum(Error) / n()) |>
  ungroup() |>
  arrange(desc(ErrorRate_per_block))

temp2 <- temp |>
  filter(ErrorRate_per_block >= 0.5) |>
  group_by(Illusion_Type, Block) |>
  summarize(n = n()) |>
  arrange(desc(n), Illusion_Type) |>
  ungroup() |>
  mutate(
    n_trials = cumsum(n * 56),
    p_trials = n_trials / nrow(df)
  )

# knitr::kable(temp2)

p1 <- temp |>
  estimate_density(at = c("Illusion_Type", "Block"), method="KernSmooth") |>
  ggplot(aes(x = x, y = y)) +
  geom_line(aes(color = Illusion_Type, linetype = Block)) +
  geom_vline(xintercept = 0.5, linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  labs(y = "Distribution", x = "Error Rate") +
  theme_modern()

p2 <- temp2 |>
  mutate(Block = fct_rev(Block)) |>
  ggplot(aes(x = Illusion_Type, y = p_trials)) +
  geom_bar(stat = "identity", aes(fill = Block)) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_continuous(labels = scales::percent, expand = c(0, 0)) +
  labs(y = "Percentage of Trials Removed", x = "Illusion Type") +
  theme_modern() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p1 | p2


# Drop
n <- nrow(df)
df <- df |>
  group_by(Participant, Illusion_Type, Block) |>
  mutate(ErrorRate_per_block = sum(Error) / n()) |>
  ungroup() |>
  filter(ErrorRate_per_block < 0.5) |>
  select(-ErrorRate_per_block)

# Drop also participant with bad second block
df <- filter(
  df,
  !(Participant %in% partial_outliers & df$Block == 2))

rm(temp, temp2)
```

We removed `r n-nrow(df)` (`r insight::format_value((n-nrow(df)) / n, as_percent=TRUE)`) trials belonging to bad blocks.

### Reaction Time per Trial

```{r outliers_RTtrials, message=FALSE, warning=FALSE}
df <- df |>
  group_by(Participant, Error) |>
  mutate(Outlier = ifelse(Error == 0 & (RT < 125 | standardize(RT) > 4), TRUE, FALSE)) |>
  ungroup()

p1 <- df |> 
  filter(RT < 10000) |> 
  estimate_density(select = "RT", at = "Participant") |>
  group_by(Participant) |>
  normalize(select = "y") |>
  ungroup() |>
  merge(df |>
    filter(Error == 0) |>
    group_by(Participant) |>
    summarize(Outlier = mean(RT) + 4 * sd(RT))) |>
  mutate(Outlier = ifelse(x >= Outlier, TRUE, FALSE)) |>
  ggplot(aes(x = x, y = y)) +
  geom_area(data = normalize(estimate_density(filter(df, RT < 10000), select = "RT"), select = "y"), alpha = 0.2) +
  geom_line(aes(color = Participant, linetype = Outlier), alpha=0.2) +
  geom_vline(xintercept = c(125), linetype = "dashed", color = "red") +
  scale_color_material_d("rainbow", guide = "none") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  guides(linetype = "none") +
  coord_cartesian(xlim = c(0, 4000)) +
  theme_modern() +
  theme(axis.text.y = element_blank()) +
  labs(y = "", x = "Reaction Time (ms)")


p2 <- df |>
  group_by(Participant) |>
  summarize(Outlier = sum(Outlier) / n()) |>
  mutate(Participant = fct_reorder(Participant, Outlier)) |>
  ggplot(aes(x = Participant, y = Outlier)) +
  geom_bar(stat = "identity", aes(fill = Participant)) +
  scale_fill_material_d("rainbow", guide = "none") +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0), labels = scales::percent) +
  see::theme_modern() +
  theme(axis.text.x = element_blank()) +
  labs(y = "Percentage of outlier trials")

p1 / p2
```

We removed `r sum(df$Outlier)` (`r insight::format_value(sum(df$Outlier) / nrow(df), as_percent=TRUE)`) outlier trials (125 ms < RT < 4 SD above mean).

```{r message=FALSE, warning=FALSE}
df <- filter(df, Outlier == FALSE)
df$RT <- df$RT / 1000  # Convert to second for better model convergence
```



## Participants



```{r message=FALSE, warning=FALSE}
dfsub <- df |>
  group_by(Participant) |>
  select(Participant, Age, Sex, Ethnicity, Education, Nationality, Duration, Break_Duration, Device_OS, starts_with("Screen"), starts_with("IPIP6"), starts_with("PID5")) |>
  slice(1) |>
  ungroup()
```

The final sample included `r report::report_participants(dfsub, age="Age", sex="Sex")`.


# Results


```{r test_ISI, eval=FALSE, message=FALSE, warning=FALSE}
# Test where ISI needs to be included
rez <- data.frame()
for(ill in c("Delboeuf", 
             "Ebbinghaus", 
             "Rod-Frame",
             "Vertical-Horizontal", 
             "Zöllner",
             "White",
             "Müller-Lyer", 
             "Ponzo", 
             "Poggendorff",
             "Contrast")) {
  print(ill)
  print("===================")
  m1 <- brms::brm(
    Error ~ poly(ISI, 2) + (poly(ISI, 2) | Participant),
    data = filter(df, Illusion_Type == ill),
    family = "bernoulli",
    algorithm="meanfield"
  )
  m2 <- brms::brm(
    brms::bf(
      RT ~ poly(ISI, 2) + (1 | Participant),
      sigma ~ poly(ISI, 2),
      beta ~ poly(ISI, 2)
    ),
    data = filter(df, Illusion_Type == ill, Error == 0),
    family = "exgaussian",
    init=0,
    iter = 4000,
    algorithm="meanfield"
  )
  rez <- rbind(
    bayestestR::describe_posterior(as.data.frame(m1))[2:3, ],
    bayestestR::describe_posterior(as.data.frame(m2))[4:9, ]
  ) |> 
    mutate(Illusion = ill) |> 
    rbind(rez)
}
```


```{r make_GAMs, eval=FALSE, message=FALSE, warning=FALSE}
for(ill in c("Delboeuf", 
             "Ebbinghaus", 
             "Rod-Frame",
             "Vertical-Horizontal", 
             "Zöllner",
             "White",
             "Müller-Lyer", 
             "Ponzo", 
             "Poggendorff",
             "Contrast")) {
  print(ill)
  model <- brms::brm(
    Error ~ t2(Illusion_Difference, Illusion_Strength, k=8, bs="cr") + (1 | Participant),
    data = filter(df, Illusion_Type == ill),
    family = "bernoulli",
    algorithm="sampling"
  )

  name <- paste0("gam_", tolower(clean_illusionName(ill)), "_err")
  assign(name, model)  # Rename with string
  save(list=name, file=paste0("models/", name, ".Rdata"))
  
  model <- brms::brm(
    brms::bf(
      RT ~ t2(Illusion_Difference, Illusion_Strength, k=8, bs="cr") + poly(ISI, 2) + (1 | Participant),
      sigma ~ t2(Illusion_Difference, Illusion_Strength, k=8, bs="cr") + poly(ISI, 2) + (1 | Participant),
      beta ~ t2(Illusion_Difference, Illusion_Strength, k=8, bs="cr") + poly(ISI, 2) + (1 | Participant)
    ),
    data = filter(df, Illusion_Type == ill, Error == 0),
    family = "exgaussian",
    init=0,
    algorithm="sampling"
  )
  
  name <- paste0("gam_", tolower(clean_illusionName(ill)), "_rt")
  assign(name, model)  # Rename with string
  save(list=name, file=paste0("models/", name, ".Rdata"))
}
```


## Models {.tabset}


### Delboeuf

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Delboeuf")

# mm <- model.matrix(Error ~ abs(Illusion_Strength) * Illusion_Effect, data=data)
# head(as.data.frame(mm))
```

```{r bestmodels_delboeuf, message=FALSE, warning=FALSE, cache=cache, eval=bestModels}
best_models(data)

# m1 <- glmmTMB::glmmTMB(Error ~ sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect + (1 | Participant), data = data, family = "binomial")
# m2 <- glmmTMB::glmmTMB(Error ~ sqrt(Illusion_Difference) * sqrtmod(Illusion_Strength) + (1 | Participant), data = data, family = "binomial")
# 
# compare_performance(m1, m2, metrics = c("R2", "BIC"))
# test_performance(m1, m2)
```


#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data)
```



##### Model Specification


```{r m_err_delboeuf, message=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) +
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_delboeuf_err <- brms::brm(formula,
  data = data,
  refresh = 100
)

save(model_delboeuf_err, file="models/model_delboeuf_err.Rdata")
```

##### Model Inspection


```{r message=FALSE, warning=FALSE, eval=TRUE}
load("models/model_delboeuf_err.RData")
load("models/gam_delboeuf_err.RData")

# parameters::parameters(model_delboeuf_err)
```

```{r message=FALSE, warning=FALSE, cache=cache}
p_delboeuf_err <- plot_model_err(data, model_delboeuf_err, gam_delboeuf_err)
```



#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Delboeuf", Error == 0)

plot_descriptive_rt(data)
```

##### Model Specification

```{r m_rt_delboeuf, message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
formula <- brms::bf(
  RT ~ Illusion_Effect / (sqrt(Illusion_Difference) * logmod(abs(Illusion_Strength))) +  
    poly(ISI, 2) +
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * logmod(abs(Illusion_Strength))) | Participant),
  sigma ~ Illusion_Effect / (sqrt(Illusion_Difference) * logmod(abs(Illusion_Strength))) +  
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (sqrt(Illusion_Difference) * logmod(abs(Illusion_Strength))) +  
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


# brms::get_prior(formula, data = data)
# plot(seq(-5, 5, length.out=100), brms::dstudent_t(seq(-5, 5, length.out=100), df = 3, 0.1, 0.5))
# priors <- c(
  # Intercept
  # prior("student_t(3, 0, 0.1)", class = "Intercept"),
  # prior("student_t(3, 0.35, 0.1)", class = "sd", coef="Intercept", group="Participant"),
  # Default parameters
  # prior("student_t(3, 0, 3)", class = "b"),
  # prior("student_t(3, 0.35, 0.5)", class = "sd", group="Participant")
  
  # prior("student_t(3, 0, 1)", class="Intercept", dpar = "sigma"),
  # prior("student_t(3, 0.1, 1)", class="sd", dpar = "sigma")
  
  # prior("student_t(3, 0.1, 0.5)", class = "ndt")
  # ) |> 
  # brms::validate_prior(formula, data = data)

# bayestestR::model_to_priors(model_delboeuf_rt, scale_multiply=3)

model_delboeuf_rt <- brms::brm(formula,
  data = data,
  refresh = 100,
  init=0
)

save(model_delboeuf_rt, file="models/model_delboeuf_rt.Rdata")
```

##### Model Inspection


```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_delboeuf_rt.RData")
load("models/gam_delboeuf_rt.RData")

# performance::check_model(model_delboeuf_rt)
# parameters::parameters(model)
```


```{r message=FALSE, warning=FALSE, cache=cache}
# plot_ppcheck(model_delboeuf_rt, gam_delboeuf_rt)

p_delboeuf_rt <- plot_model_rt(data, model_delboeuf_rt, gam_delboeuf_rt)
```


#### Visualization

```{r message=FALSE, warning=FALSE, cache=cache, fig.height=fig.height*2}
p_delboeuf <- plot_all(data, p_delboeuf_err, p_delboeuf_rt)
p_delboeuf
```


### Ebbinghaus

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Ebbinghaus") 
```

```{r bestmodels_ebbinghaus, message=FALSE, warning=FALSE, cache=cache, eval=bestModels}
best_models(data)

# m1 <- glmmTMB::glmmTMB(Error ~ sqrt(Illusion_Difference) * logmod(abs(Illusion_Strength)) * Illusion_Effect +
#     (1 | Participant), data = data, family = "binomial")
# m2 <- glmmTMB::glmmTMB(Error ~ sqrt(Illusion_Difference) * logmod(Illusion_Strength) +
#     (1 | Participant), data = data, family = "binomial")
# 
# test_performance(m1, m2)
# compare_performance(m1, m2)
```


#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data)
```



##### Model Specification

```{r m_err_ebbinghaus, message=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (sqrt(Illusion_Difference) * abs(Illusion_Strength)) +
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * abs(Illusion_Strength)) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_ebbinghaus_err <- brms::brm(formula,
  data = data,
  refresh = 100
)

save(model_ebbinghaus_err, file="models/model_ebbinghaus_err.Rdata")
```

##### Model Inspection


```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_ebbinghaus_err.RData")
load("models/gam_ebbinghaus_err.RData")

# parameters::parameters(model_delboeuf_err)
```


```{r message=FALSE, warning=FALSE, cache=cache}
p_ebbinghaus_err <- plot_model_err(data, model_ebbinghaus_err, gam_ebbinghaus_err)
```



#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Ebbinghaus", Error == 0)

plot_descriptive_rt(data)
```


##### Model Specification

```{r m_rt_ebbinghaus, message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  RT ~ Illusion_Effect / (sqrt(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + 
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * abs(Illusion_Strength)) | Participant),
  sigma ~ Illusion_Effect / (sqrt(Illusion_Difference) * abs(Illusion_Strength)) + 
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (sqrt(Illusion_Difference) * abs(Illusion_Strength)) + 
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


model_ebbinghaus_rt <- brms::brm(formula,
  data = data,
  refresh = 100,
  init = 0
)

save(model_ebbinghaus_rt, file="models/model_ebbinghaus_rt.Rdata")
```

##### Model Inspection


```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
load("models/model_ebbinghaus_rt.RData")
load("models/gam_ebbinghaus_rt.RData")

# performance::check_model(model_delboeuf_rt)
# parameters::parameters(model)
```


```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
# # plot_ppcheck(model_ebbinghaus_rt, gam_ebbinghaus_rt)

p_ebbinghaus_rt <- plot_model_rt(data, model_ebbinghaus_rt, gam_ebbinghaus_rt)
```


#### Visualization

```{r message=FALSE, warning=FALSE, cache=cache, fig.height=fig.height*2, eval=TRUE}
p_ebbinghaus <- plot_all(data, p_ebbinghaus_err, p_ebbinghaus_rt)
p_ebbinghaus
```


### Rod and Frame

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Rod-Frame")
```

```{r bestmodels_rodframe, message=FALSE, warning=FALSE, cache=cache, eval=bestModels}
best_models(data)

m1 <- glmmTMB::glmmTMB(Error ~ logmod(Illusion_Difference) * logmod(abs(Illusion_Strength)) * Illusion_Effect +
    (1 | Participant), data = data, family = "binomial")
m2 <- glmmTMB::glmmTMB(Error ~ logmod(Illusion_Difference) * logmod(Illusion_Strength) +
    (1 | Participant), data = data, family = "binomial")

compare_performance(m1, m2)
test_performance(m1, m2)
```

#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data)
```


##### Model Specification

```{r m_err_rodframe, message=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (logmod(Illusion_Difference) * logmod(Illusion_Strength)) +
    (1 + Illusion_Effect / (logmod(Illusion_Difference) * logmod(Illusion_Strength)) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_rodframe_err <- brms::brm(formula,
  data = data,
  refresh = 100
)

# parameters::parameters(model_delboeuf_err)

save(model_rodframe_err, file="models/model_rodframe_err.Rdata")
```

##### Model Inspection


```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_rodframe_err.RData")
load("models/gam_rodframe_err.RData")
```



```{r message=FALSE, warning=FALSE, cache=cache}
p_rodframe_err <- plot_model_err(data, model_rodframe_err, gam_rodframe_err)
```


#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Rod-Frame", Error == 0)

plot_descriptive_rt(data)
```


##### Model Specification

```{r m_rt_rodframe, message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  RT ~ Illusion_Effect / (logmod(Illusion_Difference) * logmod(abs(Illusion_Strength))) +
    poly(ISI, 2) + 
    (1 + Illusion_Effect / (logmod(Illusion_Difference) * logmod(abs(Illusion_Strength))) | Participant),
  sigma ~ Illusion_Effect / (logmod(Illusion_Difference) * logmod(abs(Illusion_Strength))) + 
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (logmod(Illusion_Difference) * logmod(abs(Illusion_Strength))) + 
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


model_rodframe_rt <- brms::brm(formula,
  data = data,
  refresh = 100,
  init = 0
)

save(model_rodframe_rt, file="models/model_rodframe_rt.Rdata")
```

##### Model Inspection


```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
load("models/model_rodframe_rt.RData")
load("models/gam_rodframe_rt.RData")

# performance::check_model(model_delboeuf_rt)
# parameters::parameters(model)
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
# plot_ppcheck(model_rodframe_rt, gam_rodframe_rt)

p_rodframe_rt <- plot_model_rt(data, model_rodframe_rt, gam_rodframe_rt)
```


#### Visualization

```{r message=FALSE, warning=FALSE, cache=cache, fig.height=fig.height*2, eval=TRUE}
p_rodframe <- plot_all(data, p_rodframe_err, p_rodframe_rt)
p_rodframe
```



### Vertical-Horizontal

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Vertical-Horizontal") 
```

```{r bestmodels_verticalhorizontal, message=FALSE, warning=FALSE, cache=cache, eval=bestModels}
best_models(data)
```


#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data)
```


##### Model Specification

```{r m_err_verticalhorizontal, message=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) +
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_verticalhorizontal_err <- brms::brm(formula,
  data = data,
  refresh = 100
)

save(model_verticalhorizontal_err, file="models/model_verticalhorizontal_err.Rdata")
```

##### Model Inspection

```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_verticalhorizontal_err.RData")
load("models/gam_verticalhorizontal_err.RData")

# parameters::parameters(model_verticalhorizontal_err)
```

```{r message=FALSE, warning=FALSE, cache=cache}
p_verticalhorizontal_err <- plot_model_err(data, model_verticalhorizontal_err, gam_verticalhorizontal_err)
```



#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Vertical-Horizontal", Error == 0)

plot_descriptive_rt(data)
```


##### Model Specification

```{r m_rt_verticalhorizontal, message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  RT ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) +
    poly(ISI, 2) + 
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) | Participant),
  sigma ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) + 
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) + 
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


model_verticalhorizontal_rt <- brms::brm(formula,
  data = data,
  refresh = 100,
  init = 0
)

save(model_verticalhorizontal_rt, file="models/model_verticalhorizontal_rt.Rdata")
```

##### Model Inspection


```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
load("models/model_verticalhorizontal_rt.RData")
load("models/gam_verticalhorizontal_rt.RData")

# plot_ppcheck(model_verticalhorizontal_rt, gam_verticalhorizontal_rt)
# performance::check_model(model_verticalhorizontal_rt)
# parameters::parameters(model)
```


```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
p_verticalhorizontal_rt <- plot_model_rt(data, model_verticalhorizontal_rt, gam_verticalhorizontal_rt)
```


#### Visualization

```{r message=FALSE, warning=FALSE, cache=cache, fig.height=fig.height*2, eval=TRUE}
p_verticalhorizontal <- plot_all(data, p_verticalhorizontal_err, p_verticalhorizontal_rt)
p_verticalhorizontal
```



### Zöllner


#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Zöllner")
```

```{r bestmodels_zollner, message=FALSE, warning=FALSE, cache=cache, eval=bestModels}
best_models(data)
```

#### Error Rate 


##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data)
```


##### Model Specification

```{r m_err_zollner, message=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) +
    (1 + Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_zollner_err <- brms::brm(formula,
  data = data,
  refresh = 100
)

save(model_zollner_err, file="models/model_zollner_err.Rdata")
```

##### Model Inspection


```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_zollner_err.RData")
load("models/gam_zollner_err.RData")

# parameters::parameters(model_zollner_err)
```


```{r message=FALSE, warning=FALSE, cache=cache}
p_zollner_err <- plot_model_err(data, model_zollner_err, gam_zollner_err)
```


#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Zöllner", Error == 0)

plot_descriptive_rt(data)
```



##### Model Specification

```{r m_rt_zollner, message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  RT ~  Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + 
    (1 + Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) | Participant),
  sigma ~  Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


model_zollner_rt <- brms::brm(formula,
  data = data,
  refresh = 100,
  init = 0
)

save(model_zollner_rt, file="models/model_zollner_rt.Rdata")
```

##### Model Inspection


```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
load("models/model_zollner_rt.RData")
load("models/gam_zollner_rt.RData")

# plot_ppcheck(model_zollner_rt, gam_zollner_rt)
# performance::check_model(model_zollner_rt)
# parameters::parameters(model)

```

```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
p_zollner_rt <- plot_model_rt(data, model_zollner_rt, gam_zollner_rt)
```


#### Visualization

```{r message=FALSE, warning=FALSE, cache=cache, fig.height=fig.height*2, eval=TRUE}
p_zollner <- plot_all(data, p_zollner_err, p_zollner_rt)
p_zollner
```



### White


```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "White")
```

```{r bestmodels_white, message=FALSE, warning=FALSE, cache=cache, eval=bestModels}
best_models(data)
```

#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data)
```


##### Model Specification

```{r m_err_white, essage=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (Illusion_Difference * sqrt(abs(Illusion_Strength))) +
    (1 + Illusion_Effect / (Illusion_Difference * sqrt(abs(Illusion_Strength))) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_white_err <- brms::brm(formula,
  data = data,
  refresh = 100
)

# parameters::parameters(model_white_err)

save(model_white_err, file="models/model_white_err.Rdata")
```

##### Model Inspection

```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_white_err.RData")
load("models/gam_white_err.RData")
```


```{r message=FALSE, warning=FALSE, cache=cache}
p_white_err <- plot_model_err(data, model_white_err, gam_white_err)
```



#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "White", Error == 0)

plot_descriptive_rt(data)
```

##### Model Specification

```{r m_rt_white, message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
formula <- brms::bf(
  RT ~ Illusion_Effect / (logmod(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + 
    (1 + Illusion_Effect / (logmod(Illusion_Difference) * abs(Illusion_Strength)) | Participant),
  sigma ~ Illusion_Effect / (logmod(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (logmod(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


model_white_rt <- brms::brm(formula,
  data = data,
  refresh = 100,
  init = 0
)

save(model_white_rt, file="models/model_white_rt.Rdata")
```

##### Model Inspection

```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
load("models/model_white_rt.RData")
load("models/gam_white_rt.RData")

# plot_ppcheck(model_white_rt, gam_white_rt)
# performance::check_model(model_white_rt)
# parameters::parameters(model)
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
p_white_rt <- plot_model_rt(data, model_white_rt, gam_white_rt) + 
  coord_cartesian(ylim=c(0.125, 1.7), xlim = c(-17.5, 17.5))
```

#### Visualization

```{r message=FALSE, warning=FALSE, cache=cache, fig.height=fig.height*2, eval=TRUE}
p_white <- plot_all(data, p_white_err, p_white_rt)
p_white
```



### Müller-Lyer

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Müller-Lyer")
```

```{r bestmodels_mullerlyer, message=FALSE, warning=FALSE, cache=cache, eval=bestModels}
best_models(data)
```

#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data, side = "updown")
```



##### Model Specification

```{r m_err_mullerlyer, message=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) +
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_mullerlyer_err <- brms::brm(formula,
  data = data,
  refresh = 100
)

# parameters::parameters(model_white_err)

save(model_mullerlyer_err, file="models/model_mullerlyer_err.Rdata")
```

##### Model Inspection


```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_mullerlyer_err.RData")
load("models/gam_mullerlyer_err.RData")
```

```{r message=FALSE, warning=FALSE, cache=cache}
p_mullerlyer_err <- plot_model_err(data, model_mullerlyer_err, gam_mullerlyer_err)
```

#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Müller-Lyer", Error == 0)

plot_descriptive_rt(data, side = "updown")
```


##### Model Specification

```{r m_rt_mullerlyer, message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
formula <- brms::bf(
  RT ~ Illusion_Effect / (sqrt(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + 
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * abs(Illusion_Strength)) | Participant),
  sigma ~ Illusion_Effect / (sqrt(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (sqrt(Illusion_Difference) * abs(Illusion_Strength)) + 
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


model_mullerlyer_rt <- brms::brm(formula,
  data = data,
  refresh = 100,
  init = 0
)

save(model_mullerlyer_rt, file="models/model_mullerlyer_rt.Rdata")
# parameters::parameters(model_white_err)
```

##### Model Inspection


```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
load("models/model_mullerlyer_rt.RData")
load("models/gam_mullerlyer_rt.RData")

# plot_ppcheck(model_mullerlyer_rt, gam_mullerlyer_rt)
# performance::check_model(model_mullerlyer_rt)
# parameters::parameters(model)
```


```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
p_mullerlyer_rt <- plot_model_rt(data, model_mullerlyer_rt, gam_mullerlyer_rt)
```

#### Visualization

```{r message=FALSE, warning=FALSE, cache=cache, fig.height=fig.height*2, eval=TRUE}
p_mullerlyer <- plot_all(data, p_mullerlyer_err, p_mullerlyer_rt)
p_mullerlyer
```


### Ponzo

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Ponzo")
```

```{r bestmodels_ponzo, message=FALSE, warning=FALSE, cache=cache, eval=bestModels}
best_models(data)
```

#### Error Rate 


##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data, side = "updown")
```


##### Model Specification

```{r m_err_ponzo, message=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) +
    (1 + Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_ponzo_err <- brms::brm(formula,
  data = data,
  refresh = 100
)

# parameters::parameters(model_ponzo_err)

save(model_ponzo_err, file="models/model_ponzo_err.Rdata")
```

##### Model Inspection

```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_ponzo_err.RData")
load("models/gam_ponzo_err.RData")
```

```{r message=FALSE, warning=FALSE, cache=cache}
p_ponzo_err <- plot_model_err(data, model_ponzo_err, gam_ponzo_err)
```


#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Ponzo", Error == 0)

plot_descriptive_rt(data, side = "updown")
```


##### Model Specification

```{r m_rt_ponzo, message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
formula <- brms::bf(
  RT ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + 
    (1 + Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) | Participant),
  sigma ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


model_ponzo_rt <- brms::brm(formula,
  data = data,
  refresh = 100,
  init = 0
)

save(model_ponzo_rt, file="models/model_ponzo_rt.Rdata")
# parameters::parameters(model_white_err)
```

##### Model Inspection


```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
load("models/model_ponzo_rt.RData")
load("models/gam_ponzo_rt.RData")

# plot_ppcheck(model_ponzo_rt, gam_ponzo_rt)
# performance::check_model(model_ponzo_rt)
# parameters::parameters(model)
```


```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
p_ponzo_rt <- plot_model_rt(data, model_ponzo_rt, gam_ponzo_rt)
```

#### Visualization

```{r message=FALSE, warning=FALSE, cache=cache, fig.height=fig.height*2, eval=TRUE}
p_ponzo <- plot_all(data, p_ponzo_err, p_ponzo_rt)
p_ponzo
```


### Poggendorff

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Poggendorff")
```

```{r bestmodels_poggendorff, message=FALSE, warning=FALSE, cache=cache, eval=bestModels}
best_models(data)
```


#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data, side = "updown")
```

##### Model Specification

```{r m_err_poggendorff, message=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * sqrt(abs(Illusion_Strength))) +
    (1 + Illusion_Effect / (cbrtmod(Illusion_Difference) * sqrt(abs(Illusion_Strength))) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_poggendorff_err <- brms::brm(formula,
  data = data,
  refresh = 100
)

# parameters::parameters(model_poggendorff_err)

save(model_poggendorff_err, file="models/model_poggendorff_err.Rdata")
```

##### Model Inspection

```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_poggendorff_err.RData")
load("models/gam_poggendorff_err.RData")
```


```{r message=FALSE, warning=FALSE, cache=cache}
p_poggendorff_err <- plot_model_err(data, model_poggendorff_err, gam_poggendorff_err)
```


#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Poggendorff", Error == 0)

plot_descriptive_rt(data, side = "updown")
```

##### Model Specification

```{r m_rt_poggendorff, message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
formula <- brms::bf(
  RT ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + 
    (1 + Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) | Participant),
  sigma ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) + 
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) + 
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


model_poggendorff_rt <- brms::brm(formula,
  data = data,
  refresh = 100,
  init = 0
)

save(model_poggendorff_rt, file="models/model_poggendorff_rt.Rdata")
```

##### Model Inspection


```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
load("models/model_poggendorff_rt.RData")
load("models/gam_poggendorff_rt.RData")

# plot_ppcheck(model_poggendorff_rt, gam_poggendorff_rt)
# performance::check_model(model_poggendorff_rt)
# parameters::parameters(model)
```


```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
p_poggendorff_rt <- plot_model_rt(data, model_poggendorff_rt, gam_poggendorff_rt)
```


#### Visualization

```{r message=FALSE, warning=FALSE, cache=cache, fig.height=fig.height*2, eval=TRUE}
p_poggendorff <- plot_all(data, p_poggendorff_err, p_poggendorff_rt)
p_poggendorff
```



### Contrast

#### Model Selection


```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Contrast")
```

```{r bestmodels_contrast, message=FALSE, warning=FALSE, cache=cache, eval=bestModels}
best_models(data)
```


#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Contrast")

plot_descriptive_err(data, side = "updown")
```


##### Model Specification

```{r m_err_contrast, message=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) +
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_contrast_err <- brms::brm(formula,
  data = data,
  refresh = 100
)

# parameters::parameters(model_contrast_err)

save(model_contrast_err, file="models/model_contrast_err.Rdata")
```

##### Model Inspection

```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_contrast_err.RData")
load("models/gam_contrast_err.RData")
```

```{r message=FALSE, warning=FALSE, cache=cache}
p_contrast_err <- plot_model_err(data, model_contrast_err, gam_contrast_err)
```



#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Contrast", Error == 0)

plot_descriptive_rt(data, side = "updown")
```

##### Model Specification

```{r m_rt_contrast, message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
formula <- brms::bf(
  RT ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) +
    poly(ISI, 2) + 
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) | Participant),
  sigma ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) + 
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) + 
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


model_contrast_rt <- brms::brm(formula,
  data = data,
  refresh = 50,
  init = 0
)

save(model_contrast_rt, file="models/model_contrast_rt.Rdata")
```

##### Model Inspection

```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
load("models/model_contrast_rt.RData")
load("models/gam_contrast_rt.RData")

# plot_ppcheck(model_contrast_rt, gam_contrast_rt)
# performance::check_model(model_contrast_rt)
# parameters::parameters(model)
```


```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
p_contrast_rt <- plot_model_rt(data, model_contrast_rt, gam_contrast_rt)
```

#### Visualization

```{r message=FALSE, warning=FALSE, cache=cache, fig.height=fig.height*2, eval=TRUE}
p_contrast <- plot_all(data, p_contrast_err, p_contrast_rt)
p_contrast
```


## Individual Scores

### Extraction


```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
data <- rbind(
  extract_random(model_delboeuf_err, "Delboeuf"),
  # extract_random(model_delboeuf_rt, "Delboeuf"),
  extract_random(model_ebbinghaus_err, "Ebbinghaus"),
  # extract_random(model_ebbinghaus_rt, "Ebbinghaus"),
  extract_random(model_rodframe_err, "Rod-Frame"),
  # extract_random(model_rodframe_rt, "Rod-Frame"),
  extract_random(model_verticalhorizontal_err, "Vertical-Horizontal"),
  # extract_random(model_verticalhorizontal_rt, "Vertical-Horizontal"),
  extract_random(model_zollner_err, "Zöllner"),
  # extract_random(model_zollner_rt, "Zöllner"),
  extract_random(model_white_err, "White"),
  # extract_random(model_white_rt, "White"),
  extract_random(model_mullerlyer_err, "Müller-Lyer"),
  # extract_random(model_mullerlyer_rt, "Müller-Lyer"),
  extract_random(model_ponzo_err, "Ponzo"),
  # extract_random(model_ponzo_rt, "Ponzo"),
  extract_random(model_poggendorff_err, "Poggendorff"),
  # extract_random(model_poggendorff_rt, "Poggendorff"),
  extract_random(model_contrast_err, "Contrast")
  # extract_random(model_contrast_rt, "Contrast")
) |> 
  filter(
    !str_detect(Parameter, "Intercept_"),
    !str_detect(Parameter, "Cong"),
    !str_detect(Parameter, "Cong_Prob"),
    !str_detect(Parameter, "Null_"),
    !str_detect(Parameter, "Diff_"))  |> 
  mutate(Parameter = str_remove(Parameter, "_Prob"))


data |> 
  ggplot(aes(y = Median, x = Participant)) +
  geom_pointrange(aes(ymin=CI_low, ymax=CI_high, color=Parameter), size=0.5) +
  geom_hline(yintercept = 0, linetype = "dotted") +
  facet_wrap(Parameter~Illusion_Type, scales = "free") +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  coord_flip()


random <- data |>
  mutate(Parameter = paste0(Illusion_Type, "_", Parameter),
         Parameter = clean_illusionName(Parameter)) |>
  select(Participant, Parameter, Median) |> 
  pivot_wider(names_from = Parameter, values_from = Median) |> 
  mutate_if(is.numeric, function(x) x / sd(x, na.rm=TRUE)) 

random[is.na(random)] <- 0

# x <- ranef(model_delboeuf_err, robust=TRUE)$Participant
# random2 <- x[1:250, 
#              "Estimate",
#              c("Illusion_EffectIncongruent:sqrtabsIllusion_Strength",
#                "Illusion_EffectIncongruent:sqrtIllusion_Difference:sqrtabsIllusion_Strength")] |> 
#   as.data.frame()
# cor(arrange(random2, row.names(random2)), arrange(random[2:3], random$Participant))
```



### Correlation 

```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
cor <- correlation::correlation(random, redundant = TRUE, p_adjust = "none")

p_data <- cor |>
  mutate(
    Parameter1 = prettify_parameterName(Parameter1),
    Parameter2 = prettify_parameterName(Parameter2)
  ) |>
  correlation::cor_sort(hclust_method = "ward.D2") |>
  cor_lower() |>
  mutate(
    Text = insight::format_value(r, zap_small = TRUE, digits = 3),
    Text = str_replace(str_remove(Text, "^0+"), "^-0+", "-"),
    Text = paste0(Text, insight::format_p(p, stars_only = TRUE)),
    Parameter2 = fct_rev(Parameter2)
  )


p_data |>
  ggplot(aes(x = Parameter2, y = Parameter1)) +
  geom_tile(aes(fill = r)) +
  geom_text(aes(label = Text), size = rel(2), alpha=2/3) +
  scale_fill_gradient2(low = "#2196F3", mid = "white", high = "#F44336", midpoint = 0, limit = c(-1, 1), space = "Lab", name = "Correlation", guide = "legend") +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) +
  labs(title = "Correlation Matrix", x = NULL, y = NULL) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

# estimate_density(p_data$r, at=as.character(sign(p_data$r))) |> 
#   ggplot(aes(x=x, y=y, color=Group)) +
#   geom_line()
```


### Factor Analysis

#### First Level

```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
data <- select(random, -Participant)

rez <- parameters::n_factors(data, n_max=15)
rez
plot(rez)


fa <- parameters::factor_analysis(data,
  cor = as.matrix(cor),
  n = 7,
  rotation = "oblimin",
  fm = "mle",
  sort = TRUE
)

insight::print_md(fa)

plot(fa) +
  theme_minimal()
# psych::omega(data, fm = "mle", nfactors=7)
# fa <- psych::fa.multi(as.matrix(cor), nfactors = 3, nfact2 = 1, n.obs = nrow(random))
# psych::fa.multi.diagram(fa)
```

#### Second Level

```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
data <- predict(fa)

rez <- parameters::n_factors(data, rotation = "varimax")
plot(rez)

fa2 <- parameters::factor_analysis(data,
  n = 2,
  rotation = "varimax",
  fm = "mle",
  sort = TRUE
)

insight::print_md(fa2)
```


### Sructural Equation Model


```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
library(lavaan)

names <- names(select(random, -Participant))
data <- setNames(as.data.frame(str_split_fixed(names, "_", 2)), c("Illusion_Type", "Parameter"))
data$Name <- names

# Model 0 - EFA
model <- "
i2 =~ RodFrame_Strength + RodFrame_Interaction + VerticalHorizontal_Strength + VerticalHorizontal_Interaction + MullerLyer_Strength + MullerLyer_Interaction + Ponzo_Strength + Ponzo_Interaction
Zollner =~ Zollner_Strength + Zollner_Interaction
White =~ White_Strength + White_Interaction
Ebbinghaus =~ Ebbinghaus_Strength + Ebbinghaus_Interaction
Poggendorff =~ Poggendorff_Strength + Poggendorff_Interaction
Contrast =~ Contrast_Strength + Contrast_Interaction
Delboeuf =~ Delboeuf_Strength + Delboeuf_Interaction
i =~ i2 + Zollner + White + Ebbinghaus + Poggendorff + Contrast
"

m0 <- sem(model = model,
          data  = random,
          bounds = "standard",
          estimator = "ML",
          ) 

# Model 1 - by Illusion
lvl1 <- paste(data$Illusion_Type, "=~", data$Name)
lvl2 <- paste("i =~", unique(data$Illusion_Type))
resid <- as.data.frame(t(utils::combn(x=unique(data$Illusion_Type), 2)))
resid <- paste(resid$V1, "~~", resid$V2)

m1 <- sem(model = paste0(c(lvl1, lvl2), collapse = "\n"),
          data  = random,
          bounds = "standard",
          estimator = "ML",
          ) 


# Model 1b - without Delboeuf
m1b <- sem(model = paste0(c(lvl1, lvl2[lvl2 != "i =~ Delboeuf"]), collapse = "\n"),
          data  = random,
          bounds = "standard",
          estimator = "ML",
          ) 


# Model 2 - by type
model <- "
Lines =~ MullerLyer_Strength + MullerLyer_Interaction + Ponzo_Strength + Ponzo_Interaction + VerticalHorizontal_Strength + VerticalHorizontal_Interaction
Circles =~ Ebbinghaus_Strength + Ebbinghaus_Interaction + Delboeuf_Strength + Delboeuf_Interaction
Contrast =~ Contrast_Strength + Contrast_Interaction + White_Strength + White_Interaction
Angle =~ Zollner_Strength + Zollner_Interaction + Poggendorff_Strength + Poggendorff_Interaction  + RodFrame_Strength + RodFrame_Interaction
i =~ Lines + Circles + Contrast + Angle 
"

m2 <- sem(model = model,
          data  = random,
          bounds = "standard",
          estimator = "ML"
          )


# Model 3 - by Parameter
lvl1 <- paste(data$Parameter, "=~", data$Name)
lvl2 <- paste("i =~", unique(data$Parameter))
resid <- as.data.frame(t(utils::combn(x=unique(data$Parameter), 2)))
resid <- paste(resid$V1, "~~", resid$V2)

m3 <- sem(model = paste0(c(lvl1, lvl2), collapse = "\n"),
          data  = random,
          bounds = "standard",
          estimator = "ML"
          )


# Model 4 - No middle level
lvl1 <- paste("i =~", data$Name)

m4 <- sem(model = paste0(c(lvl1), collapse = "\n"),
          data  = random,
          bounds = "standard",
          estimator = "ML"
          )

anova(m0, m1, m1b, m2, m4)

summary(m1, standardize = TRUE, fit.measures = TRUE)
```

```{r message=FALSE, warning=FALSE, cache=cache, fig.width=30, fig.height=15}
# https://cjvanlissa.github.io/tidySEM/articles/sem_graph.html
library(ggraph)
library(tidySEM)

colors <- c("i" = "#9C27B0", 
            "Delboeuf"="#2196F3", 
            "Ebbinghaus"="#3F51B5",
            "Rod-Frame"="#F44336", "Rod\nFrame"="#F44336", 
            "Vertical-Horizontal"="#FF5722", "Vertical\nHorizontal"="#FF5722",
            "Zöllner"="#FF9800",
            "White"="#9E9E9E", 
            "Müller-Lyer" = "#4CAF50", "Müller\n-Lyer" = "#4CAF50",
            "Ponzo" = "#009688",
            "Poggendorff"="#795548",
            "Contrast"="#607D8B", 
            "black"="black")

edges <- tidySEM::get_edges(m1) |> 
  mutate(color = ifelse(sign(as.numeric(est)) >= 0, "1", "-1"),
         width = abs(as.numeric(est)),
         type = ifelse(from == "i", "curved", "straight")) |> 
  filter(lhs != rhs)

nodes <- tidySEM::get_nodes(m1) |> 
  mutate(label = prettify_parameterName(name),
         angle = ifelse(grepl("_", name), 90, 0),
         hjust = case_when(
           grepl("_", name) ~ 1.15,
           name == "i" ~ 0.5,
           TRUE ~ 0.5),
         size = case_when(
           grepl("_", name) ~ 1,
           name == "i" ~ 7,
           TRUE ~ 6),
         textsize = case_when(
           grepl("_", name) ~ 1,
           name == "i" ~ 3,
           TRUE ~ 1.1),
         face = case_when(
           grepl("_", name) ~ "italic",
           name == "i" ~ "bold.italic",
           TRUE ~ "plain"),
         color = str_remove_all(label, " - .*"),
         textcolor = ifelse(grepl("_", name), "black", "white"),
         label = str_remove_all(label, ".* - "),
         label = str_replace(label, "Müller-Lyer", "Müller\n-Lyer"),
         label = str_replace(label, "Rod-Frame", "Rod\nFrame"),
         label = str_replace(label, "Vertical-Horizontal", "Vertical\nHorizontal"),
         family = ifelse(name == "i", "serif", "sans"))


p_sem <- tidygraph::tbl_graph(nodes = nodes, edges = edges) |> 
  ggraph(layout = "sugiyama") +
  geom_edge_arc(aes(filter=type!="straight",
                    edge_width = width,
                    color = color,
                    label=est_std),
                strength = 0.03 * c(-1, -1, -1, -1, -1, 1, 1, 1, 1, 1),
                angle_calc="along",
                label_dodge=unit(-0.015, "npc"),
                label_size = rel(8)) +
  geom_edge_link(aes(filter=type=="straight",
                     edge_width = width, 
                     color = color,
                     label=est_std), 
                 angle_calc="along", 
                 label_dodge=unit(-0.015, "npc"),
                 label_size = rel(8)) +
  geom_node_point(aes(shape = shape, color=color, size=size)) +
  geom_node_text(aes(label = label, angle = angle, hjust=hjust),
                 color=nodes$textcolor, 
                 fontface=nodes$face,
                 size = rel(nodes$textsize*10),
                 family=nodes$family) +
  scale_y_continuous(expand = expansion(add=c(0.42, 0.32))) +
  scale_edge_width_continuous(range=c(0.3, 6)) +
  scale_edge_color_manual(values=c("1"="#263238", "-1"="#B71C1C")) +
  scale_color_manual(values=colors, guide="none") +
  scale_shape_manual(values=c("oval"="circle", "rect"="square"), guide="none") +
  scale_size_continuous(range = c(10, 95), guide="none") +
  guides(edge_colour = "none", edge_width = "none") + 
  labs(title = "Structural Equation Model")  +
  theme_graph() +
  theme(plot.title = element_text(hjust=0.5))

p_sem
ggsave("figures/p_sem.png", p_sem, width=30, height=15)
save(p_sem, file="models/p_sem.Rdata")


dfsem <- mutate(as.data.frame(predict(m1)), Participant = random$Participant)
```


```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
# Variance Explained
SumCy <- sum(cov(random[-1]), na.rm = TRUE)

get_r2 <- function(data, dat, SumCy) {
  Cx <- cov(data)
  Cxy <- cov(data, dat)
  solved <- tryCatch(solve(Cx), error = function(e) NULL)
  if (is.null(solved)) {
    return(NA)
    next
  } else {
    VAF <- t(Cxy) %*% solved %*% Cxy
    return(sum(VAF, na.rm = TRUE) / SumCy)
  }
}
var <- get_r2(data=dfsem["i"], dat=random[-1], SumCy)
```

Factor *i* explained `r insight::format_percent(var)` of the variance of the dataset.

### Empirical Descriptors

```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
# Average for 4 higher level of task difficulty
empirical <- df |>
  # filter(Participant == "S01", Illusion_Type == "Poggendorff", Illusion_Difference <= 0.03) |> 
  filter(Illusion_Effect == "Incongruent") |>
  arrange(Participant, Illusion_Type, Illusion_Difference) |>
  group_by(Participant, Illusion_Type) |>
  # select(Participant, Block, Illusion_Effect, Illusion_Type, Illusion_Strength, Illusion_Difference, Error) |>
  # print(n=20)
  slice(1:(8*2)) |> 
  # select(Illusion_Strength, Illusion_Difference)
  # group_by(Participant, Illusion_Type) |>
  summarize(
    # Illusion_Strength= mean(Illusion_Strength),
    # Illusion_Difference=mean(Illusion_Difference),
    TaskHard_Error = sum(Error, na.rm=TRUE) / n(),
    TaskHard_RTMean = mean(ifelse(Error == 0, RT, NA), na.rm=TRUE)
    # Illu_RTSpread = sd(ifelse(Error == 0, RT, NA), na.rm=TRUE),
  ) |>
  ungroup() |> 
  mutate(Illusion_Type = clean_illusionName(Illusion_Type))  |> 
  pivot_wider(names_from = c("Illusion_Type"), values_from = c("TaskHard_Error", "TaskHard_RTMean"), names_glue = "{Illusion_Type}_{.value}") 


# Average for 4 higher level of illusion strength
empirical <- df |>
  filter(Illusion_Effect == "Incongruent") |> 
  arrange(Participant, Illusion_Type, desc(Illusion_Strength)) |>
  group_by(Participant, Illusion_Type) |>
  slice(1:(8*2)) |> 
  # group_by(Participant, Illusion_Type) |>
  summarize(
    # Illusion_Strength= mean(Illusion_Strength),
    # Illusion_Difference=mean(Illusion_Difference),
    IlluStrong_Error = sum(Error, na.rm=TRUE) / n(),
    IlluStrong_RTMean = mean(ifelse(Error == 0, RT, NA), na.rm=TRUE)
    # Diff_RTSpread = sd(ifelse(Error == 0, RT, NA), na.rm=TRUE),
  ) |>
  ungroup() |> 
  mutate(Illusion_Type = clean_illusionName(Illusion_Type))  |> 
  pivot_wider(names_from = c("Illusion_Type"), values_from = c("IlluStrong_Error", "IlluStrong_RTMean"), names_glue = "{Illusion_Type}_{.value}") |> 
  full_join(empirical, by = "Participant") 
```


```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
r <- correlation(arrange(dfsem, as.character(Participant)), 
                 arrange(empirical, as.character(Participant)), 
                 sort=TRUE, p_adjust="none")

r |>
  mutate(label = insight::format_p(p, stars_only=TRUE),
         Type = ifelse(str_detect(Parameter2, "_Error"), "Error", "RT")) |> 
  ggplot(aes(x = Parameter1, y = Parameter2)) +
  geom_tile(aes(fill = r)) +
  geom_text(aes(label=label)) +
  scale_alpha_continuous(range = c(1, 0.5)) +
  scale_fill_gradient2(low = "#2196F3", mid = "white", high = "#F44336", midpoint = 0, limit = c(-1, 1), space = "Lab", name = "Correlation", guide = "legend") +
  facet_wrap(~Type, scales="free") +
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 45, hjust=1)) 
```






```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
# Save data
dfsub |> 
  merge(dfsem, by = "Participant") |> 
  write.csv("../data/study3.csv", row.names = FALSE)
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
# Figure 1a
# -----------
for(i in c("delboeuf", "ebbinghaus", "rodframe", "verticalhorizontal", "zollner", "white", "mullerlyer", "ponzo", "poggendorff", "contrast")) {
  load(paste0("models/model_", i, "_err.RData"))
  load(paste0("models/gam_", i, "_err.RData"))
  load(paste0("models/model_", i, "_rt.RData"))
  load(paste0("models/gam_", i, "_rt.RData"))
}
load("models/p_sem.RData")


p_delboeuf <- plot_all(
  filter(df, Illusion_Type == "Delboeuf"), 
  plot_model_err(filter(df, Illusion_Type == "Delboeuf"), model_delboeuf_err, gam_delboeuf_err), 
  plot_model_rt(filter(df, Illusion_Type == "Delboeuf", Error == 0), model_delboeuf_rt, gam_delboeuf_rt), 
  question="Which red circle is bigger?")
p_ebbinghaus <- plot_all(
  filter(df, Illusion_Type == "Ebbinghaus"), 
  plot_model_err(filter(df, Illusion_Type == "Ebbinghaus"), model_ebbinghaus_err, gam_ebbinghaus_err), 
  plot_model_rt(filter(df, Illusion_Type == "Ebbinghaus", Error == 0), model_ebbinghaus_rt, gam_ebbinghaus_rt), 
  question="Which red circle is bigger?")
p_rodframe <- plot_all(
  filter(df, Illusion_Type == "Rod-Frame"), 
  plot_model_err(filter(df, Illusion_Type == "Rod-Frame"), model_rodframe_err, gam_rodframe_err), 
  plot_model_rt(filter(df, Illusion_Type == "Rod-Frame", Error == 0), model_rodframe_rt, gam_rodframe_rt), 
  question="Which side does the red line lean to?")
p_verticalhorizontal <- plot_all(
  filter(df, Illusion_Type == "Vertical-Horizontal"), 
  plot_model_err(filter(df, Illusion_Type == "Vertical-Horizontal"), model_verticalhorizontal_err, gam_verticalhorizontal_err), 
  plot_model_rt(filter(df, Illusion_Type == "Vertical-Horizontal", Error == 0), model_verticalhorizontal_rt, gam_verticalhorizontal_rt), 
  question="Which red segment is longer?")
p_zollner <- plot_all(
  filter(df, Illusion_Type == "Zöllner"), 
  plot_model_err(filter(df, Illusion_Type == "Zöllner"), model_zollner_err, gam_zollner_err), 
  plot_model_rt(filter(df, Illusion_Type == "Zöllner", Error == 0), model_zollner_rt, gam_zollner_rt), 
  question="Which side do the red lines close on?")
p_white <- plot_all(
  filter(df, Illusion_Type == "White"), 
  plot_model_err(filter(df, Illusion_Type == "White"), model_white_err, gam_white_err), 
  plot_model_rt(filter(df, Illusion_Type == "White", Error == 0), model_white_rt, gam_white_rt) + coord_cartesian(ylim=c(0.125, 1.7), xlim = c(-17.5, 17.5)), 
  question="Which verticalcolumn\nis lighter?")
p_mullerlyer <- plot_all(
  filter(df, Illusion_Type == "Müller-Lyer"), 
  plot_model_err(filter(df, Illusion_Type == "Müller-Lyer"), model_mullerlyer_err, gam_mullerlyer_err), 
  plot_model_rt(filter(df, Illusion_Type == "Müller-Lyer", Error == 0), model_mullerlyer_rt, gam_mullerlyer_rt), 
  question="Which red line is longer?")
p_ponzo <- plot_all(
  filter(df, Illusion_Type == "Ponzo"), 
  plot_model_err(filter(df, Illusion_Type == "Ponzo"), model_ponzo_err, gam_ponzo_err), 
  plot_model_rt(filter(df, Illusion_Type == "Ponzo", Error == 0), model_ponzo_rt, gam_ponzo_rt), 
  question="Which red line\nis longer?")
p_poggendorff <- plot_all(
  filter(df, Illusion_Type == "Poggendorff"), 
  plot_model_err(filter(df, Illusion_Type == "Poggendorff"), model_poggendorff_err, gam_poggendorff_err), 
  plot_model_rt(filter(df, Illusion_Type == "Poggendorff", Error == 0), model_poggendorff_rt, gam_poggendorff_rt), 
  question="Which side is the right\npart of the red segment\nmisplaced towards?")
p_contrast <- plot_all(
  filter(df, Illusion_Type == "Contrast"), 
  plot_model_err(filter(df, Illusion_Type == "Contrast"), model_contrast_err, gam_contrast_err), 
  plot_model_rt(filter(df, Illusion_Type == "Contrast", Error == 0), model_contrast_rt, gam_contrast_rt), 
  question="Which small rectangle\nis lighter?")

# Vertical
p_ill <- 
  (p_delboeuf + p_ebbinghaus + 
     p_rodframe + p_verticalhorizontal +
     p_zollner + p_white +
     p_mullerlyer + p_ponzo +
     p_poggendorff + p_contrast) + 
    patchwork::plot_layout(ncol= 2, nrow=5) 

ggsave("figures/figure_ill2.png", p_ill, height = 40, width = 20, dpi=300)

# Horizontal
p_ill <- 
  (p_delboeuf + p_ebbinghaus + 
     p_rodframe + p_verticalhorizontal +
     p_zollner + p_white +
     p_mullerlyer + p_ponzo +
     p_poggendorff + p_contrast) + 
    patchwork::plot_layout(ncol= 5, nrow=2) 

ggsave("figures/figure_ill.png", p_ill, height = 20, width = 30, dpi=300)


ggsave("../figures/figure3.png", ((p_ill) / p_sem) + plot_layout(heights=c(2, 1.5)), height = 35, width = 30, dpi=300)
```

# Discussion


This study confirmed that it was possible to continuously manipulate the effect of illusion strength for 10 classic illusions. Increasing the illusion strength increased the likelihood of errors, as well as the average and spread of RTs (but only up to a point, after which participants become faster at responding with the wrong answer). Future studies are needed to explore reaction times and identify the most appropriate models, and/or use models that integrate both errors and reaction time (e.g., drift diffusion models).

The effect on errors was monotonic for most illusions, with the exception of Delboeuf and Zöllner. For both of them, mildly congruent illusion strengths (which theoretically were supposed to be associated with fewer errors than incongruent effects) were related to small and strong increases of errors, respectively. For the Delboeuf illusion, we believe that this was due to an artifact caused by the illusion generation algorithm: the outline of the target circles was always created as slightly bigger, which made the difference between them more obvious at an illusion strength of 0. This was fixed in the latest release of *Pyllusion* (v1.2), which now generates outlines of the same size as the target circle. For the Zöllner illusion, the observed non-monotonic pattern is actually consistent with previous reports [@kitaoka2000; @kitaoka2007], suggesting an acute angle contraction effect at very small - as well as at sufficiently large angles (below 10 degrees for the former and between 50 to 90 degrees for the latter) between the target horizontal line and the biasing horizontal bars when the illusion strength is weak.

Finally, this study provided evidence for both the existence of illusion-specific factors, as well as for a common latent factor (labelled Factor *i*) that explained about half of the total variance. These participant-level scores were positively related to the error rate and average reaction time, and can thus be interpreted as indices of illusion sensitivity.

# References
